#!/usr/bin/env zsh
# Obtains the command to run and full path to log
# in its directory and outputs to it plus two other
# locations (/tmp and ~/.config/csrv)
local -A Config

local CACHE var_name=$1 cmd_name=$2 data_file=$3
local -a args
shift 3

Config=( "${(@PAkv)var_name}" )
CACHE=${ZSRV_THIS_CACHE:-${ZSH_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}}}
CACHE+=/commandsrv

# Create cacbe dir.
command mkdir -p $CACHE

# Get the run entity.
local cmd=$Config[main__runnable] tpe=$Config[main__type]

# Get the arguments.
csrv-get-args $var_name
args=( "$reply[@]" )

local stdin=${Config[io__in]:-stdin} stdout=${Config[io__out]:-stdout} \
        stderr=${Config[io__err]:-stderr}
local -a text=( "${args[@]}" "&>>!\"\$CACHE/$cmd_name.out\""
              "&>>|\"\$data_file\"" )
reply=( "$text[@]" )

# Append any redirections.
csrv-extend-iocmd-text 0 $stdin "$reply[@]"
csrv-extend-iocmd-text 1 $stdout "$reply[@]"
csrv-extend-iocmd-text 2 $stderr "$reply[@]"
# Prepend any command wrappers like sh -c ….
csrv-extend-typecmd-text INI $cmd "$reply[@]"

text=( "$reply[@]" )

# Run via eval to allow e.g.: cmd="env PATH=… command"
# or cmd="command -C …"
(
    local rundir=$Config[main__run-dir] pth=$Config[main__path] \
        fpth=$Config[main__fpath]
    typeset -gUx FPATH PATH
    csnon_empty $pth && path=( "${(s.:.)${(@Q)${(@z)pth}}}" $path )
    csnon_empty $fpth && fpath=( "${(s.:.)${(@Q)${(@z)fpth}}}" $fpath )

    if [[ -n $rundir ]]; then
        command mkdir -p $rundir
        builtin cd -q $rundir
    fi
    repeat 1 { builtin eval "$text[@]"; }
) &
# Save the PID of the background command
local tmp=$!-$? key=CMD_${(U)cmd}_PID
Plugins[$key]=${tmp%-*}
REPLY=${tmp%-*}
return ${tmp#*-}


# vim:ft=zsh:sw=4:sts=4:ts=8:et
